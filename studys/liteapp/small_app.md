[微信小程序底层原理](https://juejin.cn/post/6999654431729909767)
[小程序底层实现原理及一些思考](https://zhuanlan.zhihu.com/p/81775922)

# 双线程模型
双线程: 一个 JsCore 单线程, 多个 WebView 渲染线程

线程通信: 通过 Native 中转 (setData)
网络请求: 通过 Native 转发 (request)

为什么?
  1. 安全: 从根本上禁止了操作 DOM 和 BOM 的能力
  2. 性能: 逻辑和渲染实现了并行 (没有浏览器需要等 Js 操作 DOM 的情况)
代价: 
  1. setData 效率低不能频繁触发
  2. 一些 DOM 和 BOM 操作不能用限制了开发能力

组件系统
原生 HTML 非常原始和开发, 直接使用 HTML 开发会削弱可管控性, 因此微信设计了一个 框架 Exparser
Exparser 内置在小程序的基础库中, 所有组件, 包括内置和自定义组件, 都由 Exparser 组织管理
Exparser 的组件模型与 WebComponents 的 ShadowDOM 高度相似, 相当于一个简化版的 ShadowDOM 实现

原生渲染能力
```html
<map latitude="39.92" longtitude="116.46"></map>
``` 
上面这行代码在某一个渲染线程中开始被执行时, 会经历以下几个步骤:
  1. 组件实例被创建, 包括组件的属性会依次被赋值给这个实例
  2. 组件实例被插入到 DOM 树里 (通过 Exparser), webview 内核开始计算它的布局
  3. 组件实例知道自己是原生组件, 通知客户端, 客户端在它的 (webview 算出的) 位置上按宽高插入一块原生区域
  4. 客户端在插入的原生区域上渲染界面
  5. 此后每当位置或宽高发生变化, 组件会通知客户端做一次原生区域相应的调整
也就是 webview 上面只是一个占位元素, 之后客户端会在这个占位元素上盖一层大小相同的原生界面
这也是为什么, 原生组件的 层级 会比非原生组件或标签要高, 即 z-index 管不了它

但是现在微信有一种 [同层渲染](https://developers.weixin.qq.com/community/develop/article/doc/000c4e433707c072c1793e56f5c813) 的技术可以使 z-index 同样对原生组件有效

引入原生组件可以获得更好的 Native 控制能力, 以及更好的体验, 并减轻 webview (渲染线程) 的负担
同时带来一些限制, 比如一些 css 样式不生效

# 小程序的本质
小程序和快应用最大的不同, 就是它其实是个网页
包括 UI 渲染和事件交互在内的绝大部分功能都是基于 web 技术, 以及加了一些 Native 的能力和 API
但是 web 技术太开放了, 开发者几乎可以为所欲为, 小程序必须限制这种情况
要做到这点就只能对 web 渲染层进行一个分离与托管, 也就是把 Js 代码放到一个隔绝的沙箱中运行

# 小程序跨平台
各超级 APP 平台小程序架构实现的不同, APIs 的碎片化, 导致需要单独开发
如果可以使用一种 DSL (如 vue) 去开发所有小程序(包括快应用), 就好了

各种各样的小程序多端方案其核心主要是
  - 编译结合运行时方案

假如我们选 Vue 作为 DSL, 微信小程序作为目标
Vue 的单文件组件包含三部分
  - template
  - script
  - style
分别能对应 WX小程序中的
  - .wxml
  - .js + .json
  - .wxss
style 最多经过一次 postcss 转化可以直接给小程序 .wxss 用
template 转换为 .wxml 文件需要经过一次语法转换, 例如标签名, 指令, 事件绑定等
template 的转换可以用正则, 但是正则比较复杂, 依赖 AST 反而可以简化, Babel 生态就有很多开箱即用的工具
我们得到 template 的 AST, 对它进行修改, 然后用新 AST 生成 .wxml 的内容

最难搞的 script 部分
一般在 .vue 文件的 script 部分, 我们会导出一个对象, 这个对象会作为创建当前组件实例的参数
```js
new Vue({
  data() {},
  methods() {},
  components() {},
})
```
我们这个 Vue 在小程序里, 是不能处理渲染工作的, 它只能修改数据
同时这个 Vue 也不需要模板编译能力, 所以我们引入一个 Vue 的运行时版本, 来执行我们写在 script 里的代码

然后我们发现微信小程序规定页面 js 中必须有一个 Page() (或 Component()) 方法, 以生成一个小程序页面实例
那么我们还必须执行这个方法让微信去创建小程序实例, 同时将 Vue 实例和这个小程序实例进行关联
```js
// 在 Vue 实例化事时, 会调用 init 方法
Vue.init = () => {
  // ... 保留 Vue.init 原有逻辑
  // 调用微信小程序的 Page 方法
  Page({
    // ... config ...
    onLoad: function(options) {
      // 在这里可以把 this 交给 Vue 实例
    }
  })
}
new Vue({ /* ... config ... */ })
```
Vue 实例在拥有了小程序实例的能力后, 就可以让 Vue 实例数据变化时不去更新 vdom
而是直接把观察到的数据更新包装为 setData 交给小程序渲染层自己的 vdom 去进行 diff
这样一来, 我们需要的是不是一个比运行时版 Vue 更小的, 不包含 vdom 的版本呢?

此外, 跨平台还要考虑事件处理, 性能优化等, 以后继续深究

但是, 这种跨平台方案说到底只是在做翻译, 只能算作不得已而为之的临时性方案
真正的终极技术方案, 有两种:
  从渲染引擎层面抹平平台差异, 例如: Flutter, 但是很不容易
  各小程序开发厂商公共制定一套标准和规范, 例如: 学习一下浏览器